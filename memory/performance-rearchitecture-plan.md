# Color / Piece / Move / Position / Record 抜本的パフォーマンス改善計画（メジャーアップデート向け）

## 0. 先行タスク: パフォーマンステストの増強（最優先）

> 既存比較可能な定量指標を先に作り、最適化の効果と退行を継続監視する。

### 0-1. ベンチマークの層を増やす
- **マイクロベンチ**（純粋な型・変換コスト）
  - `Color`/`Piece`/`Move` の生成・比較・シリアライズ（USI/SFEN/CSA 変換）。
  - `Position` の `doMove` / `undoMove` / `clone` / ハッシュ更新。
  - `Record` の append / jump / 分岐探索 / コメント更新。
- **シナリオベンチ**（アプリ実運用に近い）
  - 長手数棋譜読み込み→全手再生→分岐追加→書き出し。
  - USI 解析情報の大量入力（既存 `USIPlayerMonitor` ベンチ拡張）。
- **メモリ/GC ベンチ**
  - ノード数 1k / 10k / 100k の `Record` でヒープサイズ・GC 回数・stop-the-world 時間を測定。

### 0-2. 既存ベンチの拡張ポイント
- `src/tests/renderer/store/usi.bench.ts` は USI 更新処理の代表ベンチとして存在するため、**手数増加・PV 長増加・複数局面混在**のケースを追加。  
- `src/tests/background/book/apery.bench.ts` は大規模データ読み込みのベンチとして存在するため、**読み込み後アクセス（検索・反復参照）**まで測定範囲を拡大。

### 0-3. 計測運用
- CI で `vitest bench` を定期実行し、結果を JSON 保存して前回比較。
- KPI 例
  - `Position.doMove` p95 実行時間
  - `Record` 10k ノード構築時間
  - `USI update` 1万件処理時間
  - ピーク RSS / GC 回数

---

## 1. 現状ボトルネック仮説（文字列 / class / 配列）

### 1-1. 文字列中心処理
- コメント復元などで `split("\n")` + 複数 regex の反復評価が多く、ノード数比例でコスト増大。
- USI/SFEN/CSA などの文字列表現を頻繁に再構築し、同一内容の重複生成が起きやすい。

### 1-2. class インスタンス多用
- `Move`/`Piece`/`Position` が class ベースだと、生成頻度の高い箇所で **オブジェクト割り当て + GC** が律速になりやすい。
- 等価比較が参照比較/都度プロパティ比較に依存し、キャッシュキー化しづらい。

### 1-3. 配列/オブジェクトグラフ
- `Record` の分岐木をオブジェクト参照中心で保持すると、局所性が悪く巡回時のキャッシュミスが増える。
- `Position` の盤面・持駒が可変オブジェクト/配列中心だと clone コストが高い。

---

## 2. データ表現の再設計方針（破壊的変更を許容）

### 2-1. Color
- `enum`/文字列をやめ、**2値の数値表現（0/1）** に統一。
- API 境界だけ `black|white` 文字列へ変換（内部は常に number）。

### 2-2. Piece
- class ではなく **packed integer（例: 5〜8bit）** へ。
  - 例: `color(1bit) + type(4bit) + promoted(1bit)`
- `Piece` オブジェクト生成を廃止し、必要時のみ view 関数で展開。

### 2-3. Move
- class をやめ **32bit packed move** へ。
  - `from(7bit) + to(7bit) + drop(1bit) + promote(1bit) + piece(4bit) + captured(4bit) + flags`
- 生成・比較・Map キー利用を整数演算化し、PV/棋譜処理の割り当てを削減。

### 2-4. Position
- **Struct of Arrays + TypedArray** へ移行。
  - 盤: `Int16Array(81)`
  - 持駒: `Uint8Array(2 * pieceTypeCount)`
  - 手番/手数/ハッシュ: 数値フィールド
- 差分適用型 `doMove/undoMove` を標準化し、フル clone を原則禁止。
- ハッシュは差分更新を徹底（zobrist を継続利用）。

### 2-5. Record
- ノードを class 木ではなく **インデックス参照アリーナ** で管理。
  - `parentIndex[]`, `firstChildIndex[]`, `nextSiblingIndex[]`, `move[]`, `commentOffset[]`
- コメント本文は string プール（重複排除）で保持。
- 主変化・分岐巡回は index 走査に寄せ、再帰より反復処理を優先。

---

## 3. 文字列処理最適化（特に効果が大きい候補）

### 3-1. パーサの段階化
- `split` 多用を避け、1-pass 字句走査へ置換。
- regex 連打を最小化し、固定フォーマット箇所は手続きパースに変更。

### 3-2. 変換キャッシュ
- `USI <-> MovePacked`、`SFEN <-> PositionSnapshot` を LRU キャッシュ。
- 解析表示で繰り返し出る PV 文字列を intern 化。

### 3-3. 不変文字列の集約
- コメントタグ（例: 評価値、詰み、深さ）を定数テーブル化し、連結回数を削減。

---

## 4. 信頼性維持戦略（将棋ルールの既存ロジックを活かす）

### 4-1. ルール実装の二重化を避ける
- 合法手判定・千日手/入玉などのルール中核は既存ロジックを維持。
- 新表現は **アダプタ層** で既存ロジックに受け渡し、差分が生じない設計にする。

### 4-2. 差分検証（Differential Testing）
- 旧実装と新実装で以下を全件照合。
  - 合法手集合
  - `doMove/undoMove` 後の局面一致
  - SFEN/USI/KIF/CSA 入出力同値
- ランダム局面 + 実棋譜大量再生で比較。

### 4-3. 退行防止
- バグ発見が難しいルール周りは、既存テスト資産を温存しつつ **同一期待値** で新APIテストを追加。
- 重大機能（棋譜読込、分岐、詰み/反則判定）にゴールデンテストを設定。

---

## 5. API/移行計画（メジャーアップデート前提）

### 5-1. 新旧 API 併存期間
- `V2` 名前空間（例: `Move32`, `PositionState`, `RecordArena`）を先行導入。
- 旧 class API から V2 への変換アダプタを用意し、段階移行。

### 5-2. 破壊的変更の方針
- public API は「生成/比較/シリアライズ」を中心に再定義。
- 内部アクセス用の可変プロパティは原則非公開化。

### 5-3. 廃止手順
1. V2 実装 + ベンチ導入
2. 主要呼び出し箇所を V2 化（UI 表示層は最後）
3. 旧 API を deprecated
4. メジャーリリースで削除

---

## 6. 実行ロードマップ

### Phase 1（2〜3週間）: 計測基盤
- ベンチ増強、計測ダッシュボード整備、KPI 凍結。

### Phase 2（3〜5週間）: Move/Piece/Color の packed 化
- 変換アダプタ + 差分テストを同時実装。

### Phase 3（4〜6週間）: Position の SoA/TypedArray 化
- `do/undo` 最適化、ハッシュ差分更新、clone 排除。

### Phase 4（3〜5週間）: Record のアリーナ化
- ノード/コメント管理再設計、分岐巡回高速化。

### Phase 5（2〜3週間）: 文字列処理最適化 + 総合検証
- import/export・USI 処理の 1-pass 化、全差分テスト、リリース判定。

---

## 7. 期待効果（目標レンジ）
- `Move` 生成/比較: **3〜10倍**
- `Position do/undo`: **2〜5倍**
- 大規模 `Record` 巡回: **2〜4倍**
- メモリ使用量（長手数/多分岐）: **30〜60%削減**
- GC 起因の UI スパイク: 有意に低減

---

## 8. リスクと対策
- **リスク**: packed 化で可読性が落ちる。  
  **対策**: デコードヘルパとデバッグ表示を標準提供。
- **リスク**: 新旧変換で見えにくい不整合。  
  **対策**: differential testing を CI の必須ゲートに設定。
- **リスク**: 早期最適化で複雑化。  
  **対策**: 必ずベンチ結果で採否判断（計測先行）。
